<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Inscripción - Horarios Escolares</title>
  <meta name="description" content="Simulador que te permite cargar horarios escolares, detectar empalmes, alternativas y calendario visual." />
  <meta name="keywords" content="Simulador de Inscripción, Horarios, Inscripción, Grupos, Materias" />
  <meta name="author" content="Kristoffer Van" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow" />
  <meta name="google" content="notranslate" />
  <!-- <meta name="google-site-verification" content="1234567890" /> -->

  <!-- HTML Meta Tags -->
  <title>Simulador de Inscripción - Horarios Escolares</title>
  <meta name="description" content="Simulador que te permite cargar horarios escolares, detectar empalmes, alternativas y calendario visual.">

  <!-- Facebook Meta Tags -->
  <meta property="og:url" content="https://simulador-inscripcion-horarios.krisv.dev/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Simulador de Inscripción - Horarios Escolares">
  <meta property="og:description" content="Simulador que te permite cargar horarios escolares, detectar empalmes, alternativas y calendario visual.">
  <meta property="og:image" content="https://opengraph.b-cdn.net/production/images/b7605ab1-015a-4f53-aaaa-ef906d15881f.png?token=ma9cA7Dm-jqCrdPeWfdR23_G7lPxcCiFPJxDSgvIqhY&height=675&width=1200&expires=33291144476">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="simulador-inscripcion-horarios.krisv.dev">
  <meta property="twitter:url" content="https://simulador-inscripcion-horarios.krisv.dev/">
  <meta name="twitter:title" content="Simulador de Inscripción - Horarios Escolares">
  <meta name="twitter:description" content="Simulador que te permite cargar horarios escolares, detectar empalmes, alternativas y calendario visual.">
  <meta name="twitter:image" content="https://opengraph.b-cdn.net/production/images/b7605ab1-015a-4f53-aaaa-ef906d15881f.png?token=ma9cA7Dm-jqCrdPeWfdR23_G7lPxcCiFPJxDSgvIqhY&height=675&width=1200&expires=33291144476">

  <style>
    :root{--blue:#0b74de;--muted:#f3f4f6;--card:#ffffff}
    body{font-family:Inter,Segoe UI,Arial;margin:0;background:#f5f7fa;color:#111}
    header{background:linear-gradient(90deg,var(--blue),#3aa0ff);color:#fff;padding:14px 18px}
    .wrap{display:flex;gap:12px;padding:12px}
    .panel{background:var(--card);border-radius:8px;padding:12px;box-shadow:0 1px 4px rgba(0,0,0,.08)}
    .left-column{width:360px;max-height:100vh;overflow:auto;display:flex;flex-direction:column}
    .main{flex:1}
    h2{margin:6px 0 12px}
    .materia{border:1px solid #e6e9ee;padding:8px;border-radius:6px;margin-bottom:8px}
    .grupo{display:flex;align-items:center;gap:8px;margin:6px 0}
    .btn{background:var(--blue);color:#fff;padding:8px 10px;border-radius:6px;border:0;cursor:pointer}
    .small{font-size:13px;color:#666}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    #calendar{width:100%;height:730px;border-radius:6px;overflow:auto;position:relative}
    .calendar-header{display:grid;grid-template-columns:60px repeat(5,1fr);border-top:1px solid #e6e9ee;border-bottom:1px solid #e6e9ee;position:sticky;top:0;z-index:10;background:white}
    .header-cell{padding:6px;font-weight:bold;background:#f8f9fa;border-right:1px solid #e6e9ee;text-align:center}
    .grid{display:grid;grid-template-columns:60px repeat(5,1fr)}
    .timecell{border-right:1px solid #e6e9ee;padding:6px;font-size:12px;background:#fafbfd}
    .daycol{min-height:40px;border-right:1px solid #e6e9ee;position:relative}
    .slot{position:absolute;border-radius:6px;padding:6px;font-size:12px;color:#fff}
    .combo-list{max-height:180px;overflow:auto}
    footer{padding:6px 10px;font-size:11px;color:#666;text-align:center;border-top:1px solid #e6e9ee;margin:0;background:#fff}
    .badge{background:#eee;padding:4px 6px;border-radius:6px;font-size:12px}
    label.switch{display:inline-flex;align-items:center;gap:8px}
    .grupo{border-radius:4px;padding:6px;margin:4px 0;transition:background-color 0.2s}
    .grupo:hover{background-color:#f8f9fa}
    .grupo.disabled{background-color:#e9ecef !important;border:1px solid #dee2e6}
    .grupo.disabled:hover{background-color:#e9ecef !important}
    .selectGroup{accent-color:var(--blue)}
    .grupo label{cursor:pointer}
    .grupo.disabled label{cursor:not-allowed;color:#6c757d}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    h3{margin:6px 0 12px;font-size:16px}
    h4{margin:12px 0 8px;font-size:14px;color:#555}
    .hover-tooltip{position:absolute;background:#fff;border:1px solid #e6e9ee;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);padding:12px;z-index:1000;max-width:280px;font-size:13px;line-height:1.4;pointer-events:none;opacity:0;transform:translateY(10px);transition:opacity 0.2s ease,transform 0.2s ease}
    .hover-tooltip.show{opacity:1;transform:translateY(0)}
    .hover-tooltip h5{margin:0 0 8px;font-size:14px;color:#333;font-weight:600}
    .hover-tooltip .time-info{color:#666;margin-bottom:8px;font-size:12px}
    .hover-tooltip .group-item{padding:6px 8px;margin:4px 0;background:#f8f9fa;border-radius:4px;border-left:4px solid #ddd}
    .hover-tooltip .group-item.available{border-left-color:#28a745;border:2px solid #28a745}
    .hover-tooltip .group-item.full{border-left-color:#dc3545;border:2px solid #dc3545;opacity:0.7}
    .hover-tooltip .group-item.selected{border-left-color:var(--blue);background:#e3f2fd}
    .hover-tooltip .group-item.same-materia{border-left-color:#ffc107;border:2px solid #ffc107;background:#f8f9fa}
    .hover-tooltip .group-name{font-weight:500;color:#333}
    .hover-tooltip .group-details{color:#666;font-size:11px;margin-top:2px}
    .hover-tooltip .no-groups{color:#999;font-style:italic;text-align:center;padding:8px}
    .daycol:hover{background-color:rgba(11,116,222,0.02)}
  </style>
</head>
<body>
  <header>
    <strong>Simulador de Inscripción</strong>
    <div style="font-size:13px;opacity:.9">Carga de horarios, detección de empalmes, alternativas y calendario visual</div>
  </header>
  <div class="wrap">
    <div class="left-column">
      <div class="panel">
        <h2>Materias y Grupos</h2>
        <div class="small">Marca las materias que quieres inscribir y selecciona grupo(s). Puedes marcar grupos como <strong>llenos</strong> para forzar alternativas.</div>
        <div id="materiasContainer"></div>
      </div>
      
      <div class="panel" style="margin-top:12px">
        <h3 style="margin-top:0">Controles</h3>
        <div class="controls">
          <button id="computeBtn" class="btn">Calcular combinaciones</button>
          <button id="autoBtn" class="btn" style="background:#28a745">Auto llenar (con reservas)</button>
        </div>
        <div style="margin-top:8px">
          <button id="clearBtn" class="btn" style="background:#dc3545">Limpiar selección manual</button>
        </div>
        
        <h4 style="margin:12px 0 8px 0">Opciones</h4>
        <div class="small"><label class="switch"><input id="limitCombos" type="checkbox" checked> Limitar combos a 2000 (recomendado)</label></div>
        
        <div style="margin-top:12px"><strong>Combinaciones encontradas:</strong> <span id="comboCount">0</span></div>
        <div class="combo-list panel" id="combos" style="margin-top:8px"></div>
      </div>
    </div>

    <div class="panel main">
      <h2>Calendario semanal</h2>
      <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
        <div class="badge">Seleccionada: <span id="selectedCombo">-</span></div>
        <div class="small">Puedes elegir una combinación para visualizar en el calendario.</div>
        <div style="margin-left:auto"><button id="exportBtn" class="btn">Exportar selección (JSON)</button></div>
      </div>
      <div id="calendar"></div>
    </div>
  </div>

  <footer>
    © 2025 Simulador de Inscripción - Horarios. Todos los derechos reservados. | Desarrollado por <strong>Kristoffer Van</strong> (<a href="https://github.com/im-krizox" target="_blank" style="color:#0b74de;text-decoration:none;">@im-krizox</a>) | Licencia MIT
  </footer>

  <script>
    // ---------- Carga dinámica de datos (desde horarios.json) ----------
    let materias = [];
    const byMateria = {};
    let dataLoaded = false;
    const indexToGroup = {};
    const previewSelected = new Set();
    const selectedGroups = new Set(); // Track individually selected groups

    // Construye la UI agrupando todos los grupos por materia en una sola caja
    function buildMateriasUI(){
      const cont = document.getElementById('materiasContainer');
      cont.innerHTML='';
      const materiaNames = Object.keys(byMateria).sort((a,b)=>a.localeCompare(b));
      materiaNames.forEach((name, materiaIdx)=>{
        const grupos = byMateria[name];
        const div = document.createElement('div');
        div.className='materia';
        div.innerHTML = `<label><input type='checkbox' class='want' data-name='${name}'> <strong>${name}</strong> <span class='small'>(${grupos.length} grupo(s))</span></label>`;

        const gdiv = document.createElement('div');
        gdiv.style.marginTop='6px';

        grupos.forEach(g=>{
          const row = document.createElement('div');
          row.className='grupo';
          row.innerHTML = `
            <label style='display:flex;align-items:center;gap:6px;margin-right:10px'>
              <input type='checkbox' class='selectGroup' data-gi='${g._idx}' data-materia='${name}'>
            </label>
            <div style='flex:1'>Grupo ${g.grupo} — <span class='small'>${g.profesor}</span></div>
            <label style='display:flex;align-items:center;gap:6px'>
              <input type='checkbox' class='isFull' data-gi='${g._idx}'> Lleno
            </label>`;
          gdiv.appendChild(row);
        });

        div.appendChild(gdiv);
        cont.appendChild(div);
      });
      
      // Add event listeners for group selection
      setupGroupSelectionListeners();
      setupFullStatusListeners();
      
      // Apply initial full group status
      applyInitialFullGroupStatus();
    }

    // Setup event listeners for individual group selection
    function setupGroupSelectionListeners(){
      document.querySelectorAll('.selectGroup').forEach(checkbox => {
        checkbox.addEventListener('change', handleGroupSelection);
      });
    }

    // Setup event listeners for "full" status checkboxes
    function setupFullStatusListeners(){
      document.querySelectorAll('.isFull').forEach(checkbox => {
        checkbox.addEventListener('change', handleFullStatusChange);
      });
    }

    // Apply initial full group status on page load
    function applyInitialFullGroupStatus(){
      recalculateFullGroupConflicts();
    }

    // Handle individual group selection
    function handleGroupSelection(event){
      const checkbox = event.target;
      const groupIdx = parseInt(checkbox.dataset.gi);
      const materia = checkbox.dataset.materia;
      
      // REGLA: No se puede seleccionar un grupo marcado como "Lleno"
      const fullCheckbox = document.querySelector(`.isFull[data-gi="${groupIdx}"]`);
      if(fullCheckbox && fullCheckbox.checked){
        checkbox.checked = false;
        alert('No puedes seleccionar un grupo marcado como lleno.');
        return;
      }
      
      if(checkbox.checked){
        // Add to selected groups
        selectedGroups.add(groupIdx);
        
        // NUEVA REGLA: Auto-seleccionar la materia cuando se selecciona un grupo
        const materiaCheckbox = document.querySelector(`.want[data-name="${materia}"]`);
        if(materiaCheckbox){
          materiaCheckbox.checked = true;
        }
        
        // REGLA: Deshabilitar otros grupos de la misma materia
        disableGroupsFromSameMateria(materia, groupIdx);
        
        // REGLA: Deshabilitar grupos que tengan al menos un día y horario en común
        disableConflictingGroups(groupIdx);
        
        // Update calendar with currently selected groups
        updateCalendarWithSelectedGroups();
      } else {
        // Remove from selected groups
        selectedGroups.delete(groupIdx);
        
        // NUEVA REGLA: Si no quedan grupos seleccionados de esta materia, deseleccionar la materia
        const hasOtherSelectedGroups = Array.from(selectedGroups).some(idx => {
          return materias[idx].materia === materia;
        });
        if(!hasOtherSelectedGroups){
          const materiaCheckbox = document.querySelector(`.want[data-name="${materia}"]`);
          if(materiaCheckbox){
            materiaCheckbox.checked = false;
          }
        }
        
        // Re-enable all groups and recalculate conflicts
        enableAllGroups();
        recalculateConflicts();
        
        // Update calendar
        updateCalendarWithSelectedGroups();
      }
    }

    // Disable other groups from the same materia
    function disableGroupsFromSameMateria(materia, exceptGroupIdx){
      const grupos = byMateria[materia];
      grupos.forEach(g => {
        if(g._idx !== exceptGroupIdx){
          const checkbox = document.querySelector(`.selectGroup[data-gi="${g._idx}"]`);
          if(checkbox){
            checkbox.disabled = true;
            checkbox.parentElement.style.opacity = '0.5';
            // Add disabled class to the grupo container
            const grupoContainer = checkbox.closest('.grupo');
            if(grupoContainer){
              grupoContainer.classList.add('disabled');
            }
          }
        }
      });
    }

    // Disable groups that conflict with the selected group (same day and overlapping time)
    function disableConflictingGroups(selectedGroupIdx){
      const selectedGroup = materias[selectedGroupIdx];
      
      // Check all other groups for conflicts (day and time overlap)
      Object.values(byMateria).forEach(grupos => {
        grupos.forEach(g => {
          // Skip if it's the same group or already selected
          if(g._idx !== selectedGroupIdx && !selectedGroups.has(g._idx)){
            // Check if groups have conflicting schedules (same day + overlapping time)
            if(groupsConflict(selectedGroup, g)){
              const checkbox = document.querySelector(`.selectGroup[data-gi="${g._idx}"]`);
              if(checkbox){
                checkbox.disabled = true;
                checkbox.parentElement.style.opacity = '0.5';
                // Add disabled class to the grupo container
                const grupoContainer = checkbox.closest('.grupo');
                if(grupoContainer){
                  grupoContainer.classList.add('disabled');
                }
              }
            }
          }
        });
      });
    }

    // Enable all group checkboxes
    function enableAllGroups(){
      document.querySelectorAll('.selectGroup').forEach(checkbox => {
        checkbox.disabled = false;
        checkbox.parentElement.style.opacity = '1';
        // Remove disabled class from the grupo container
        const grupoContainer = checkbox.closest('.grupo');
        if(grupoContainer){
          grupoContainer.classList.remove('disabled');
        }
      });
    }

    // Disable selection for a specific group
    function disableGroupSelection(groupIdx){
      const checkbox = document.querySelector(`.selectGroup[data-gi="${groupIdx}"]`);
      if(checkbox){
        checkbox.disabled = true;
        checkbox.parentElement.style.opacity = '0.5';
        // Add disabled class to the grupo container
        const grupoContainer = checkbox.closest('.grupo');
        if(grupoContainer){
          grupoContainer.classList.add('disabled');
        }
      }
    }

    // Recalculate conflicts for currently selected groups
    function recalculateConflicts(){
      selectedGroups.forEach(groupIdx => {
        const materia = materias[groupIdx].materia;
        disableGroupsFromSameMateria(materia, groupIdx);
        disableConflictingGroups(groupIdx);
      });
    }

    // Handle "full" status change
    function handleFullStatusChange(event){
      const checkbox = event.target;
      const groupIdx = parseInt(checkbox.dataset.gi);
      const group = materias[groupIdx];
      
      if(checkbox.checked){
        // REGLA: Grupo marcado como "Lleno" no puede seleccionarse
        disableGroupSelection(groupIdx);
        
        // Si este grupo estaba seleccionado, deseleccionarlo automáticamente
        const selectCheckbox = document.querySelector(`.selectGroup[data-gi="${groupIdx}"]`);
        if(selectCheckbox && selectCheckbox.checked){
          selectCheckbox.checked = false;
          selectedGroups.delete(groupIdx);
          
          // NUEVA REGLA: Si no quedan grupos seleccionados de esta materia, deseleccionar la materia
          const materia = materias[groupIdx].materia;
          const hasOtherSelectedGroups = Array.from(selectedGroups).some(idx => {
            return materias[idx].materia === materia;
          });
          if(!hasOtherSelectedGroups){
            const materiaCheckbox = document.querySelector(`.want[data-name="${materia}"]`);
            if(materiaCheckbox){
              materiaCheckbox.checked = false;
            }
          }
          
          // Recalcular conflictos después de deseleccionar
          enableAllGroups();
          recalculateConflicts();
          recalculateFullGroupConflicts();
          
          updateCalendarWithSelectedGroups();
        }
      } else {
        // Group is no longer full - re-enable all groups and recalculate
        enableAllGroups();
        recalculateConflicts();
        // Re-apply full status for other groups marked as full
        recalculateFullGroupConflicts();
      }
    }

    // Esta función ya no es necesaria - eliminada para corregir el problema
    // de que los grupos llenos deshabilitaban otros grupos con horarios similares

    // Recalculate conflicts for all groups marked as full
    function recalculateFullGroupConflicts(){
      document.querySelectorAll('.isFull:checked').forEach(checkbox => {
        const groupIdx = parseInt(checkbox.dataset.gi);
        disableGroupSelection(groupIdx); // Disable the full group itself
        // Ya no deshabilitamos grupos conflictivos - solo el grupo específico marcado como lleno
      });
    }

    // Update calendar to show currently selected groups
    function updateCalendarWithSelectedGroups(){
      const selectedGroupObjects = Array.from(selectedGroups).map(idx => materias[idx]);
      drawCalendar(selectedGroupObjects);
      
      // Update the selected combo display
      if(selectedGroupObjects.length > 0){
        document.getElementById('selectedCombo').textContent = `${selectedGroupObjects.length} grupo(s) seleccionado(s)`;
        currentCombo = {idx: 'manual', combo: selectedGroupObjects};
      } else {
        document.getElementById('selectedCombo').textContent = '-';
        currentCombo = null;
      }
    }

    // Clear all individual group selections
    function clearIndividualSelections(){
      selectedGroups.clear();
      document.querySelectorAll('.selectGroup').forEach(checkbox => {
        checkbox.checked = false;
      });
      // NUEVA REGLA: También deseleccionar todas las materias
      document.querySelectorAll('.want').forEach(checkbox => {
        checkbox.checked = false;
      });
      enableAllGroups();
      // Re-apply full group status after enabling all
      recalculateFullGroupConflicts();
      document.getElementById('selectedCombo').textContent = '-';
      currentCombo = null;
      drawCalendar([]);
    }

    async function init(){
      try{
        // Deshabilitar acciones hasta cargar
        document.getElementById('computeBtn').disabled = true;
        document.getElementById('autoBtn').disabled = true;

        const res = await fetch('horarios.json', {cache:'no-store'});
        if(!res.ok) throw new Error('No se pudo cargar horarios.json');
        materias = await res.json();

        // Agrupar por materia
        materias.forEach((m,idx)=>{
          const key = m.materia;
          if(!byMateria[key]) byMateria[key]=[];
          byMateria[key].push({...m,_idx:idx, available:true});
        });

        buildMateriasUI();

        dataLoaded = true;
        document.getElementById('computeBtn').disabled = false;
        document.getElementById('autoBtn').disabled = false;
        
        // Mostrar el calendario con guías desde el inicio
        drawCalendar([]);
      }catch(err){
        console.error(err);
        alert('Error al cargar horarios.json. Asegúrate de que el archivo exista junto a este HTML.');
      }
    }

    // Iniciar carga al abrir la página
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // ========== FUNCIONALIDAD DE HOVER PARA EL CALENDARIO ==========
    let hoverTooltip = null;

    // Función para obtener grupos disponibles en un día y rango de tiempo específico
    function getGroupsForTimeSlot(dayIndex, startTime, endTime) {
      const groups = [];
      
      // Iterar todos los grupos de todas las materias
      Object.values(byMateria).forEach(materiaGroups => {
        materiaGroups.forEach(group => {
          // Verificar si este grupo tiene clases en el día especificado
          group.horarios.forEach(horario => {
            if (DAYMAP[horario.dia] === dayIndex) {
              const groupStart = timeToMinutes(horario.inicio);
              const groupEnd = timeToMinutes(horario.fin);
              
              // Verificar si hay overlap con el tiempo especificado
              if (overlap(startTime, endTime, groupStart, groupEnd)) {
                // Determinar el estado del grupo
                let status = 'available';
                
                // Verificar si el grupo está marcado como lleno
                const fullCheckbox = document.querySelector(`.isFull[data-gi="${group._idx}"]`);
                const isMarkedFull = fullCheckbox && fullCheckbox.checked;
                
                if (isMarkedFull) {
                  status = 'full';
                } else if (selectedGroups.has(group._idx)) {
                  status = 'selected';
                } else {
                  // Verificar si ya hay un grupo seleccionado de la misma materia
                  const hasSelectedFromSameMateria = Array.from(selectedGroups).some(selectedIdx => {
                    const selectedGroup = materias[selectedIdx];
                    return selectedGroup.materia === group.materia && selectedIdx !== group._idx;
                  });
                  
                  if (hasSelectedFromSameMateria) {
                    status = 'same-materia';
                  } else {
                    status = 'available';
                  }
                }
                
                groups.push({
                  ...group,
                  horario: horario,
                  status: status
                });
              }
            }
          });
        });
      });
      
      // Eliminar duplicados y ordenar por materia
      const uniqueGroups = groups.filter((group, index, self) => 
        index === self.findIndex(g => g._idx === group._idx)
      );
      
      return uniqueGroups.sort((a, b) => a.materia.localeCompare(b.materia));
    }

    // Función para crear el tooltip
    function createTooltip() {
      if (hoverTooltip) return hoverTooltip;
      
      hoverTooltip = document.createElement('div');
      hoverTooltip.className = 'hover-tooltip';
      document.body.appendChild(hoverTooltip);
      return hoverTooltip;
    }

    // Función para mostrar el tooltip
    function showTooltip(event, dayIndex, timeSlot) {
      if (!dataLoaded) return;
      
      const tooltip = createTooltip();
      const timeStart = 7*60 + timeSlot * 30; // 7:00 AM + slot * 30min
      const timeEnd = timeStart + 30; // 30 minutos de duración por slot
      
      const groups = getGroupsForTimeSlot(dayIndex, timeStart, timeEnd);
      
      // Formatear tiempo para mostrar
      const formatTime = (minutes) => {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
      };
      
      const startTimeStr = formatTime(timeStart);
      const endTimeStr = formatTime(timeEnd);
      const dayName = DAY_NAMES[dayIndex];
      
      // Construir contenido del tooltip
      let content = `
        <h5>Grupos disponibles</h5>
        <div class="time-info">${dayName}, ${startTimeStr} - ${endTimeStr}</div>
      `;
      
      if (groups.length === 0) {
        content += '<div class="no-groups">No hay grupos programados en este horario</div>';
      } else {
        groups.forEach(group => {
          const statusClass = group.status;
          const statusText = group.status === 'full' ? '(Lleno)' : 
                           group.status === 'selected' ? '(Seleccionado)' : 
                           group.status === 'same-materia' ? '(Misma materia ya seleccionada)' :
                           '(Disponible)';
          
          content += `
            <div class="group-item ${statusClass}">
              <div class="group-name">${group.materia} - Grupo ${group.grupo}</div>
              <div class="group-details">
                ${group.profesor} • ${group.horario.inicio}-${group.horario.fin} ${statusText}
              </div>
            </div>
          `;
        });
      }
      
      tooltip.innerHTML = content;
      
      // Posicionar tooltip
      const rect = event.target.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      
      let left = event.pageX + 10;
      let top = event.pageY - 10;
      
      // Ajustar si se sale de la pantalla
      if (left + tooltipRect.width > window.innerWidth) {
        left = event.pageX - tooltipRect.width - 10;
      }
      if (top + tooltipRect.height > window.innerHeight + window.pageYOffset) {
        top = event.pageY - tooltipRect.height - 10;
      }
      
      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
      tooltip.classList.add('show');
    }

    // Función para ocultar el tooltip
    function hideTooltip() {
      if (hoverTooltip) {
        hoverTooltip.classList.remove('show');
      }
    }

    // Utils: map days and time functions
    const DAYMAP = {LU:0, MA:1, MI:2, JU:3, VI:4};
    const DAY_NAMES = ['Lunes','Martes','Miércoles','Jueves','Viernes'];

    function timeToMinutes(t){ const [hh,mm]=t.split(':').map(Number); return hh*60+mm; }
    function overlap(aStart,aEnd,bStart,bEnd){ return Math.max(aStart,bStart) < Math.min(aEnd,bEnd); }

    // ========== REGLAS DE NEGOCIO PARA SELECCIÓN DE GRUPOS ==========
    // 1. Si un grupo está seleccionado, se deshabilitan automáticamente:
    //    - Todos los otros grupos de la misma materia
    //    - Todos los grupos que tengan al menos un día y horario en común (conflicto)
    // 2. Si un grupo está marcado como "Lleno":
    //    - Ese grupo no puede seleccionarse hasta desmarcar la casilla
    //    - NO afecta la disponibilidad de otros grupos

    // Allow selecting multiple materias; el JSON provee cada fila como un grupo distinto del mismo nombre de materia.

    // get selected desired subjects based on checked checkboxes
    function getDesiredSubjects(){
      const names = Array.from(document.querySelectorAll('.want'))
        .filter(ch=>ch.checked)
        .map(ch=>ch.dataset.name);
      const uniqueNames = [...new Set(names)];
      return uniqueNames.map(name=>({materia:name, groups: byMateria[name].map(g=>({...g}))}));
    }

    // update available flags from checkboxes
    function refreshAvailability(){
      document.querySelectorAll('.isFull').forEach(cb=>{
        const gidx = Number(cb.dataset.gi);
        const entry = materias[gidx];
        // locate group in byMateria
        const arr = byMateria[entry.materia];
        for(const gg of arr){ if(gg._idx===gidx){ gg.available = !cb.checked; break; } }
      });
    }

    // Build conflict checker for a selection: selection is array of group objects (each from materias array)
    function hasConflict(selection){
      // build list of all class times: for each group, for each horario
      const slots = [];
      for(const g of selection){
        for(const h of g.horarios){
          const day = DAYMAP[h.dia];
          const s = timeToMinutes(h.inicio), e = timeToMinutes(h.fin);
          slots.push({day,s,e,group:g});
        }
      }
      // check pairwise
      for(let i=0;i<slots.length;i++){
        for(let j=i+1;j<slots.length;j++){
          if(slots[i].day===slots[j].day && overlap(slots[i].s,slots[i].e,slots[j].s,slots[j].e)) return true;
        }
      }
      return false;
    }

    // Backtracking to generate combinations (choose one group per desired materia)
    function generateCombinations(subjects, limit=2000){
      const results=[];
      function backtrack(idx, chosen){
        if(results.length>=limit) return;
        if(idx===subjects.length){
          // check conflict
          if(!hasConflict(chosen)) results.push(chosen.map(c=>c));
          return;
        }
        const subj = subjects[idx];
        // iterate groups - only available
        for(const g of subj.groups){
          if(!g.available) continue;
          // choose g
          chosen.push(g);
          // quick conflict pruning: check newly added group conflicts with previous chosen
          let conflict=false;
          for(const prev of chosen.slice(0,-1)){
            for(const h1 of prev.horarios){
              for(const h2 of g.horarios){
                if(DAYMAP[h1.dia]===DAYMAP[h2.dia] && overlap(timeToMinutes(h1.inicio),timeToMinutes(h1.fin),timeToMinutes(h2.inicio),timeToMinutes(h2.fin))){ conflict=true; break; }
              }
              if(conflict) break;
            }
            if(conflict) break;
          }
          if(!conflict) backtrack(idx+1, chosen);
          chosen.pop();
          if(results.length>=limit) return;
        }
      }
      backtrack(0,[]);
      return results;
    }

    // UI: compute button
    document.getElementById('computeBtn').addEventListener('click',()=>{
      if(!dataLoaded){ alert('Los datos aún no se cargan. Intenta de nuevo en unos segundos.'); return; }
      
      // Clear individual group selections
      clearIndividualSelections();
      
      refreshAvailability();
      const desired = getDesiredSubjects();
      if(desired.length===0){ alert('Marca al menos una materia que quieras inscribir.'); return; }
      const limit = document.getElementById('limitCombos').checked ? 2000 : 50000;
      const combos = generateCombinations(desired, limit);
      renderCombos(combos);
    });

    // render combos
    function renderCombos(combos){
      const el = document.getElementById('combos'); el.innerHTML='';
      document.getElementById('comboCount').textContent = combos.length;
      if(combos.length===0){ el.innerHTML='<div class="small">No hay combinaciones sin empalmes con los grupos disponibles. Usa reservas o marca grupos como llenos/disp.</div>'; return; }
      combos.forEach((c,i)=>{
        const d = document.createElement('div'); d.style.borderBottom='1px dashed #eee'; d.style.padding='6px';
        d.innerHTML = `<div><strong>#${i+1}</strong> <span class='small'>(${c.length} materias)</span></div>`;
        const list = document.createElement('div'); list.className='small';
        c.forEach(g=>{ list.innerHTML += `<div>• ${g.materia} — Grupo ${g.grupo} (${g.profesor})</div>`; });
        const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Seleccionar'; btn.style.marginTop='6px';
        btn.onclick = ()=>{ selectCombo(i,c); };
        d.appendChild(list); d.appendChild(btn);
        el.appendChild(d);
      });
    }

    // select combo and draw calendar
    let currentCombo=null; function selectCombo(idx,combo){
      currentCombo={idx,combo};
      document.getElementById('selectedCombo').textContent = idx+1;
      drawCalendar(combo);
    }

    // draw calendar weekly grid (07:00-22:00)
    function drawCalendar(combo){
      const start = 7*60, end = 22*60; const step = 30; const rows = (end-start)/step;
      const cal = document.getElementById('calendar'); cal.innerHTML='';
      
      // Create sticky header
      const header = document.createElement('div'); header.className='calendar-header';
      // Empty cell for time column
      const emptyHeaderCell = document.createElement('div'); emptyHeaderCell.className='header-cell'; emptyHeaderCell.textContent='Hora';
      header.appendChild(emptyHeaderCell);
      // Day headers
      for(let d=0;d<5;d++){
        const dayHeader = document.createElement('div'); dayHeader.className='header-cell'; dayHeader.textContent = DAY_NAMES[d];
        header.appendChild(dayHeader);
      }
      cal.appendChild(header);
      
      // Create main grid
      const grid = document.createElement('div'); grid.className='grid';
      // time col
      const timecol = document.createElement('div'); timecol.style.display='grid'; timecol.style.gridTemplateRows = `repeat(${rows},40px)`;
      for(let r=0;r<rows;r++){ const t = start + r*step; const h = Math.floor(t/60).toString().padStart(2,'0')+':'+(t%60).toString().padStart(2,'0'); const cell = document.createElement('div'); cell.className='timecell'; cell.textContent=h; timecol.appendChild(cell); }
      grid.appendChild(timecol);
      
      // day columns with hover functionality
      for(let d=0;d<5;d++){
        const col = document.createElement('div'); 
        col.className='daycol'; 
        col.style.display='block'; 
        col.style.minHeight=(rows*40)+'px';
        col.dataset.day = d; // Guardar el índice del día
        
        // Crear celdas invisibles para cada slot de tiempo para detectar hover
        for(let r=0;r<rows;r++){
          const timeSlot = document.createElement('div');
          timeSlot.style.position = 'absolute';
          timeSlot.style.top = (r * 40) + 'px';
          timeSlot.style.left = '0';
          timeSlot.style.right = '0';
          timeSlot.style.height = '40px';
          timeSlot.style.zIndex = '1';
          timeSlot.dataset.timeSlot = r;
          timeSlot.dataset.day = d;
          
          // Event listeners para hover
          timeSlot.addEventListener('mouseenter', function(e) {
            const dayIndex = parseInt(this.dataset.day);
            const timeSlotIndex = parseInt(this.dataset.timeSlot);
            showTooltip(e, dayIndex, timeSlotIndex);
          });
          
          timeSlot.addEventListener('mouseleave', function() {
            hideTooltip();
          });
          
          timeSlot.addEventListener('mousemove', function(e) {
            // Actualizar posición del tooltip mientras se mueve el mouse
            if (hoverTooltip && hoverTooltip.classList.contains('show')) {
              const tooltipRect = hoverTooltip.getBoundingClientRect();
              let left = e.pageX + 10;
              let top = e.pageY - 10;
              
              // Ajustar si se sale de la pantalla
              if (left + tooltipRect.width > window.innerWidth) {
                left = e.pageX - tooltipRect.width - 10;
              }
              if (top + tooltipRect.height > window.innerHeight + window.pageYOffset) {
                top = e.pageY - tooltipRect.height - 10;
              }
              
              hoverTooltip.style.left = left + 'px';
              hoverTooltip.style.top = top + 'px';
            }
          });
          
          col.appendChild(timeSlot);
        }
        
        grid.appendChild(col);
      }
      cal.appendChild(grid);

      // place classes
      if(!combo || combo.length === 0) return;
      combo.forEach((g,gi)=>{
        g.horarios.forEach(h=>{
          const day = DAYMAP[h.dia]; if(day===undefined) return;
          const col = grid.children[day+1]; // +1 because first is time col
          const s = timeToMinutes(h.inicio), e = timeToMinutes(h.fin);
          const top = ((s - start) / (end - start)) * (rows*40) ;
          const height = ((e - s) / (end - start)) * (rows*40);
          const block = document.createElement('div'); block.className='slot';
          block.style.top = top + 'px'; block.style.left='0px'; block.style.right='6px'; block.style.width = 'calc(100% - 10px)';
          block.style.height = Math.max(28,height-4)+'px';
          block.style.background = stringToColor(g.materia);
          block.style.zIndex = '2'; // Asegurar que las clases aparezcan sobre las celdas de hover
          block.textContent = `${g.materia} — ${g.grupo} (${h.inicio}-${h.fin})`;
          col.appendChild(block);
        });
      });
    }

    // generate color by string
    function stringToColor(s){ let hash=0; for(let i=0;i<s.length;i++) hash = s.charCodeAt(i) + ((hash<<5)-hash); const c = (hash & 0x00FFFFFF).toString(16).toUpperCase(); return '#'+('00000'.substring(0,6-c.length)+c);
    }

    // Auto-fill with reserves: choose for each desired materia the first available group that doesn't conflict; if none, pick next available even if conflict and mark as reserve
    document.getElementById('autoBtn').addEventListener('click',()=>{
      if(!dataLoaded){ alert('Los datos aún no se cargan. Intenta de nuevo en unos segundos.'); return; }
      
      // Clear individual group selections
      clearIndividualSelections();
      
      refreshAvailability();
      const desired = getDesiredSubjects();
      if(desired.length===0){ alert('Marca al menos una materia.'); return; }
      const chosen=[]; const reserves=[];
      for(const subj of desired){
        let placed=false;
        // try available groups
        for(const g of subj.groups){
          if(!g.available) continue;
          // check conflict with current chosen
          let bad=false;
          for(const prev of chosen){ if(groupsConflict(prev,g)){ bad=true; break; } }
          if(!bad){ chosen.push(g); placed=true; break; }
        }
        if(!placed){
          // find any available group as reserve that may conflict
          const alt = subj.groups.find(x=>x.available);
          if(alt) reserves.push(alt);
        }
      }
      const final = chosen.concat(reserves);
      if(final.length===0){ alert('No se pudo rellenar con grupos disponibles'); return; }
      selectCombo('Auto', final);
      // show message about reserves
      if(reserves.length>0) alert('Se agregaron '+reserves.length+' como reservas (pueden empalmar). Revisa el calendario y ajusta manualmente.');
    });

    // Check if two groups have conflicting schedules (same day + overlapping time)
    function groupsConflict(a,b){
      // Compare each schedule from group A with each schedule from group B
      for(const h1 of a.horarios) {
        for(const h2 of b.horarios) {
          // Check if they are on the same day and times overlap
          if(DAYMAP[h1.dia] === DAYMAP[h2.dia] && 
             overlap(timeToMinutes(h1.inicio), timeToMinutes(h1.fin), 
                    timeToMinutes(h2.inicio), timeToMinutes(h2.fin))) {
            return true; // Conflict found
          }
        }
      }
      return false; // No conflicts
    }

    // export selection
    document.getElementById('exportBtn').addEventListener('click',()=>{
      if(!currentCombo){ alert('Selecciona una combinación antes de exportar'); return; }
      const data = {selectedIndex: currentCombo.idx, selection: currentCombo.combo};
      const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='inscripcion_seleccion.json'; a.click(); URL.revokeObjectURL(url);
    });

    // clear individual selections button
    document.getElementById('clearBtn').addEventListener('click', clearIndividualSelections);

    // initial small render
    document.getElementById('comboCount').textContent='0';
    
    // Mostrar el calendario inicial vacío una vez que el DOM esté listo
    if(document.readyState !== 'loading') {
      drawCalendar([]);
    }

  </script>
</body>
</html>
